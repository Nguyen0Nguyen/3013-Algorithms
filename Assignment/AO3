#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int x) {
        data = x;
        left = right = nullptr;
    }
};

class Bst {
private:
    Node* root;

    void _insert(Node*& sub_root, int x) {
        if (sub_root == nullptr) {
            sub_root = new Node(x);
        }
        else {
            if (x < sub_root->data) {
                _insert(sub_root->left, x);
            }
            else {
                _insert(sub_root->right, x);
            }
        }
    }

    bool _search(Node* sub_root, int x) {
        if (sub_root == nullptr) {
            return false;
        }
        if (x == sub_root->data) {
            return true;
        }
        else if (x < sub_root->data) {
            return _search(sub_root->left, x);
        }
        else {
            return _search(sub_root->right, x);
        }
    }

    void _print(Node* root) {
        if (!root) {
            return;
        }

        _print(root->right);
        cout << root->data << " ";
        _print(root->left);
    }

    Node* _delete(Node* sub_root, int x) {
        if (sub_root == nullptr) {
            return sub_root; // Node not found
        }

        // Find the node to delete
        if (x < sub_root->data) {
            sub_root->left = _delete(sub_root->left, x);
        }
        else if (x > sub_root->data) {
            sub_root->right = _delete(sub_root->right, x);
        }
        else {
            // Case 1: Node has no children (leaf node)
            if (sub_root->left == nullptr && sub_root->right == nullptr) {
                delete sub_root;
                return nullptr;
            }
            // Case 2: Node has one child
            else if (sub_root->left == nullptr) {
                Node* temp = sub_root->right;
                delete sub_root;
                return temp;
            }
            else if (sub_root->right == nullptr) {
                Node* temp = sub_root->left;
                delete sub_root;
                return temp;
            }
            // Case 3: Node has two children
            else {
                Node* temp = _minValueNode(sub_root->right);                     // Find the inorder successor
                sub_root->data = temp->data;                                     // Copy the inorder successor's value
                sub_root->right = _delete(sub_root->right, temp->data);          // Delete the inorder successor
            }
        }    

        return sub_root;
    }

    Node* _minValueNode(Node* sub_root) {
        Node* current = sub_root;
        while (current && current->left != nullptr) {
            current = current->left;
        }
        return current;
    }

public:
    Bst() {
        root = nullptr;
    }

    void insert(int x) {
        _insert(root, x);
    }

    bool search(int x) {
        return _search(root, x);
    }

    void deleteNode(int x) {
        root = _delete(root, x);
    }

    void print() {
        _print(root);
        cout << endl;
    }
};

int main() {
    Bst tree;
    tree.insert(8);
    tree.insert(3);
    tree.insert(1);
    tree.insert(11);
    tree.insert(7);
    tree.insert(15);

    cout << "Original tree: ";
    tree.print();

    // Deleting nodes
    tree.deleteNode(3);
    cout << "After deleting 3: ";
    tree.print();

    tree.deleteNode(8);
    cout << "After deleting 8: ";
    tree.print();

    return 0;
}

